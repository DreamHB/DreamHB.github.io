---
layout: post
title:  "TLS Handshake"
date:   2022-03-19 17:50:00
comments: true
categories: kotlin
---

HTTPS网络协议,可能是我们日常上网用的最多的协议了,同时有比较安全,至于它为什么安全,是怎么做到的,就是这篇文章要介绍的.

众所周知,HTTP协议是明文的,所有的内容都是很容易就被第三方拿到,并恶意修改,典型的情况就是网络运营商ß在网页中插入广告;而HTTPS是在HTTP的基础上,对内容进行加密,让内容看起来都是没有意义的乱码.


* TOC
{:toc}


### 概念

#### SSL 证书
SSL证书一般是第三方的证书机构(CA)颁发给网站的,通常它包含一下内容:
*   证书颁发对象的域名
*   颁发对象的人、组织或者设备
*   哪家CA机构颁发的
*   CA的数字签名,这个就是在认证阶段会用到
*   关联的子域名
*   证书的有效期
*   公钥

对于自签名证书,一般浏览器和客户端是不认的,会提示证书错误,或者直接终止连接.


#### 对称加密和非对称加密
*   对称加密指的是,加密和解密用的是同一个密钥,现在主流的AES
*   非对称加密则加密和解密用的是不同的密钥,一个是公钥,谁都可以拿到,一个是私钥只能自己知道,公钥加密的数据,只能私钥解密,反之亦然,主流的是RSA  

这两种加密方式各有优缺点,对称加密速度快,但是密钥交换是个问题,需要通过非对称加密方式来传输;
非对称加码安全,但是速度较慢,不适合加密大量数据.所以下面说的TLS握手阶段,是结合两种加密方式的.


### 过程  
加密过程是在网络传输层中进行的,这也是TLS(Transport Layer Security)的由来,在TCP连接建立后,开始建立TLS连接.

1.  客户端向服务端发送“Hello”消息,其中包括了客户端支持的TLS版本、支持哪些加密套件,同时生成一段随机的字符串“Client Random”
2.  服务端收到客户端发送的消息后,回复一个“Hello”消息,其中包含了选定的TLS版本,选定的加密套件,同时生成一个随机字符串“Server Random”,最重要的是,将服务器的SSL证书也发送过来.
3.  客户端根据系统中的安装的证书,来验证服务器证书是否有效,如果证书无效,则连接中止,证书有效则继续下一步
4.  客户端根据证书中的公钥,将服务端的随机字符串解密出来,并用公钥生成一个“Premaster Secret”,发送给服务端,服务端用自己的私钥解密
5.  客户端和服务端,各自基于”Client Random“、”Server Random“和”Premaster Secret“生成Session key,用于后续的数据加密
6.  客户端发送“完成”消息给服务端
7.  服务端发送“完成”给客户端
8.  握手完成,后续的通信,双方用相同的Session key进行对称加密

### 不足及解决办法
#### 不足之处  

虽然使用了HTTPS之后,可以做到安全的通信,但并不绝对,比如中间人攻击(Man-in-the-Middle),中间人在中间,让通信的两端察觉不到其存在,以为在直接通信;还有一种就是抓包,通过在客户端安装根证书,从而可以欺骗服务端,以为默认的认证,只认证服务端,从而导致通信内容被第三方获取.  

#### 解决办法
解决办法一般通过双向认证和Http公钥锁定的方式.  
默认情况下,只认证服务端的证书,那么当客户端和服务端都去验证对方的证书,则可以避免中间人攻击.  
还有一种方式就是公钥锁定,在首次通信中,服务端指定一些公钥的哈希值,并在随后的通信中要求服务器必须使用其中一个或多个来做认证.


### 引用
https://www.precisely.com/blog/data-security/aes-vs-rsa-encryption-differences  
https://www.cloudflare.com/learning/ssl/what-happens-in-a-tls-handshake/  
https://en.wikipedia.org/wiki/HTTP_Public_Key_Pinning
